// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.kong;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.kong.inputs.RouteDestinationArgs;
import com.pulumi.kong.inputs.RouteHeaderArgs;
import com.pulumi.kong.inputs.RouteSourceArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class RouteArgs extends com.pulumi.resources.ResourceArgs {

    public static final RouteArgs Empty = new RouteArgs();

    /**
     * A list of destination `ip` and `port`
     * 
     */
    @Import(name="destinations")
    private @Nullable Output<List<RouteDestinationArgs>> destinations;

    /**
     * @return A list of destination `ip` and `port`
     * 
     */
    public Optional<Output<List<RouteDestinationArgs>>> destinations() {
        return Optional.ofNullable(this.destinations);
    }

    /**
     * One or more blocks of `name` to set name of header and `values` which is a list of `string` for the header values to match on.  See above example of how to set.  These headers will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute.
     * 
     */
    @Import(name="headers")
    private @Nullable Output<List<RouteHeaderArgs>> headers;

    /**
     * @return One or more blocks of `name` to set name of header and `values` which is a list of `string` for the header values to match on.  See above example of how to set.  These headers will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute.
     * 
     */
    public Optional<Output<List<RouteHeaderArgs>>> headers() {
        return Optional.ofNullable(this.headers);
    }

    /**
     * A list of domain names that match this Route
     * 
     */
    @Import(name="hosts")
    private @Nullable Output<List<String>> hosts;

    /**
     * @return A list of domain names that match this Route
     * 
     */
    public Optional<Output<List<String>>> hosts() {
        return Optional.ofNullable(this.hosts);
    }

    /**
     * The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
     * 
     */
    @Import(name="httpsRedirectStatusCode")
    private @Nullable Output<Integer> httpsRedirectStatusCode;

    /**
     * @return The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
     * 
     */
    public Optional<Output<Integer>> httpsRedirectStatusCode() {
        return Optional.ofNullable(this.httpsRedirectStatusCode);
    }

    /**
     * A list of HTTP methods that match this Route
     * 
     */
    @Import(name="methods")
    private @Nullable Output<List<String>> methods;

    /**
     * @return A list of HTTP methods that match this Route
     * 
     */
    public Optional<Output<List<String>>> methods() {
        return Optional.ofNullable(this.methods);
    }

    /**
     * The name of the route
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the route
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Controls how the Service path, Route path and requested path are combined when sending a request to the upstream.
     * 
     */
    @Import(name="pathHandling")
    private @Nullable Output<String> pathHandling;

    /**
     * @return Controls how the Service path, Route path and requested path are combined when sending a request to the upstream.
     * 
     */
    public Optional<Output<String>> pathHandling() {
        return Optional.ofNullable(this.pathHandling);
    }

    /**
     * A list of paths that match this Route
     * 
     */
    @Import(name="paths")
    private @Nullable Output<List<String>> paths;

    /**
     * @return A list of paths that match this Route
     * 
     */
    public Optional<Output<List<String>>> paths() {
        return Optional.ofNullable(this.paths);
    }

    /**
     * When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
     * 
     */
    @Import(name="preserveHost")
    private @Nullable Output<Boolean> preserveHost;

    /**
     * @return When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
     * 
     */
    public Optional<Output<Boolean>> preserveHost() {
        return Optional.ofNullable(this.preserveHost);
    }

    /**
     * The list of protocols to use
     * 
     */
    @Import(name="protocols", required=true)
    private Output<List<String>> protocols;

    /**
     * @return The list of protocols to use
     * 
     */
    public Output<List<String>> protocols() {
        return this.protocols;
    }

    /**
     * A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
     * 
     */
    @Import(name="regexPriority")
    private @Nullable Output<Integer> regexPriority;

    /**
     * @return A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
     * 
     */
    public Optional<Output<Integer>> regexPriority() {
        return Optional.ofNullable(this.regexPriority);
    }

    /**
     * Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
     * 
     */
    @Import(name="requestBuffering")
    private @Nullable Output<Boolean> requestBuffering;

    /**
     * @return Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
     * 
     */
    public Optional<Output<Boolean>> requestBuffering() {
        return Optional.ofNullable(this.requestBuffering);
    }

    /**
     * Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: true.
     * 
     */
    @Import(name="responseBuffering")
    private @Nullable Output<Boolean> responseBuffering;

    /**
     * @return Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: true.
     * 
     */
    public Optional<Output<Boolean>> responseBuffering() {
        return Optional.ofNullable(this.responseBuffering);
    }

    /**
     * Service ID to map to
     * 
     */
    @Import(name="serviceId", required=true)
    private Output<String> serviceId;

    /**
     * @return Service ID to map to
     * 
     */
    public Output<String> serviceId() {
        return this.serviceId;
    }

    /**
     * A list of SNIs that match this Route when using stream routing.
     * 
     */
    @Import(name="snis")
    private @Nullable Output<List<String>> snis;

    /**
     * @return A list of SNIs that match this Route when using stream routing.
     * 
     */
    public Optional<Output<List<String>>> snis() {
        return Optional.ofNullable(this.snis);
    }

    /**
     * A list of source `ip` and `port`
     * 
     */
    @Import(name="sources")
    private @Nullable Output<List<RouteSourceArgs>> sources;

    /**
     * @return A list of source `ip` and `port`
     * 
     */
    public Optional<Output<List<RouteSourceArgs>>> sources() {
        return Optional.ofNullable(this.sources);
    }

    /**
     * When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
     * 
     */
    @Import(name="stripPath")
    private @Nullable Output<Boolean> stripPath;

    /**
     * @return When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
     * 
     */
    public Optional<Output<Boolean>> stripPath() {
        return Optional.ofNullable(this.stripPath);
    }

    /**
     * A list of strings associated with the Route for grouping and filtering.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<String>> tags;

    /**
     * @return A list of strings associated with the Route for grouping and filtering.
     * 
     */
    public Optional<Output<List<String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    private RouteArgs() {}

    private RouteArgs(RouteArgs $) {
        this.destinations = $.destinations;
        this.headers = $.headers;
        this.hosts = $.hosts;
        this.httpsRedirectStatusCode = $.httpsRedirectStatusCode;
        this.methods = $.methods;
        this.name = $.name;
        this.pathHandling = $.pathHandling;
        this.paths = $.paths;
        this.preserveHost = $.preserveHost;
        this.protocols = $.protocols;
        this.regexPriority = $.regexPriority;
        this.requestBuffering = $.requestBuffering;
        this.responseBuffering = $.responseBuffering;
        this.serviceId = $.serviceId;
        this.snis = $.snis;
        this.sources = $.sources;
        this.stripPath = $.stripPath;
        this.tags = $.tags;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(RouteArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private RouteArgs $;

        public Builder() {
            $ = new RouteArgs();
        }

        public Builder(RouteArgs defaults) {
            $ = new RouteArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param destinations A list of destination `ip` and `port`
         * 
         * @return builder
         * 
         */
        public Builder destinations(@Nullable Output<List<RouteDestinationArgs>> destinations) {
            $.destinations = destinations;
            return this;
        }

        /**
         * @param destinations A list of destination `ip` and `port`
         * 
         * @return builder
         * 
         */
        public Builder destinations(List<RouteDestinationArgs> destinations) {
            return destinations(Output.of(destinations));
        }

        /**
         * @param destinations A list of destination `ip` and `port`
         * 
         * @return builder
         * 
         */
        public Builder destinations(RouteDestinationArgs... destinations) {
            return destinations(List.of(destinations));
        }

        /**
         * @param headers One or more blocks of `name` to set name of header and `values` which is a list of `string` for the header values to match on.  See above example of how to set.  These headers will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute.
         * 
         * @return builder
         * 
         */
        public Builder headers(@Nullable Output<List<RouteHeaderArgs>> headers) {
            $.headers = headers;
            return this;
        }

        /**
         * @param headers One or more blocks of `name` to set name of header and `values` which is a list of `string` for the header values to match on.  See above example of how to set.  These headers will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute.
         * 
         * @return builder
         * 
         */
        public Builder headers(List<RouteHeaderArgs> headers) {
            return headers(Output.of(headers));
        }

        /**
         * @param headers One or more blocks of `name` to set name of header and `values` which is a list of `string` for the header values to match on.  See above example of how to set.  These headers will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute.
         * 
         * @return builder
         * 
         */
        public Builder headers(RouteHeaderArgs... headers) {
            return headers(List.of(headers));
        }

        /**
         * @param hosts A list of domain names that match this Route
         * 
         * @return builder
         * 
         */
        public Builder hosts(@Nullable Output<List<String>> hosts) {
            $.hosts = hosts;
            return this;
        }

        /**
         * @param hosts A list of domain names that match this Route
         * 
         * @return builder
         * 
         */
        public Builder hosts(List<String> hosts) {
            return hosts(Output.of(hosts));
        }

        /**
         * @param hosts A list of domain names that match this Route
         * 
         * @return builder
         * 
         */
        public Builder hosts(String... hosts) {
            return hosts(List.of(hosts));
        }

        /**
         * @param httpsRedirectStatusCode The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
         * 
         * @return builder
         * 
         */
        public Builder httpsRedirectStatusCode(@Nullable Output<Integer> httpsRedirectStatusCode) {
            $.httpsRedirectStatusCode = httpsRedirectStatusCode;
            return this;
        }

        /**
         * @param httpsRedirectStatusCode The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
         * 
         * @return builder
         * 
         */
        public Builder httpsRedirectStatusCode(Integer httpsRedirectStatusCode) {
            return httpsRedirectStatusCode(Output.of(httpsRedirectStatusCode));
        }

        /**
         * @param methods A list of HTTP methods that match this Route
         * 
         * @return builder
         * 
         */
        public Builder methods(@Nullable Output<List<String>> methods) {
            $.methods = methods;
            return this;
        }

        /**
         * @param methods A list of HTTP methods that match this Route
         * 
         * @return builder
         * 
         */
        public Builder methods(List<String> methods) {
            return methods(Output.of(methods));
        }

        /**
         * @param methods A list of HTTP methods that match this Route
         * 
         * @return builder
         * 
         */
        public Builder methods(String... methods) {
            return methods(List.of(methods));
        }

        /**
         * @param name The name of the route
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the route
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param pathHandling Controls how the Service path, Route path and requested path are combined when sending a request to the upstream.
         * 
         * @return builder
         * 
         */
        public Builder pathHandling(@Nullable Output<String> pathHandling) {
            $.pathHandling = pathHandling;
            return this;
        }

        /**
         * @param pathHandling Controls how the Service path, Route path and requested path are combined when sending a request to the upstream.
         * 
         * @return builder
         * 
         */
        public Builder pathHandling(String pathHandling) {
            return pathHandling(Output.of(pathHandling));
        }

        /**
         * @param paths A list of paths that match this Route
         * 
         * @return builder
         * 
         */
        public Builder paths(@Nullable Output<List<String>> paths) {
            $.paths = paths;
            return this;
        }

        /**
         * @param paths A list of paths that match this Route
         * 
         * @return builder
         * 
         */
        public Builder paths(List<String> paths) {
            return paths(Output.of(paths));
        }

        /**
         * @param paths A list of paths that match this Route
         * 
         * @return builder
         * 
         */
        public Builder paths(String... paths) {
            return paths(List.of(paths));
        }

        /**
         * @param preserveHost When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
         * 
         * @return builder
         * 
         */
        public Builder preserveHost(@Nullable Output<Boolean> preserveHost) {
            $.preserveHost = preserveHost;
            return this;
        }

        /**
         * @param preserveHost When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
         * 
         * @return builder
         * 
         */
        public Builder preserveHost(Boolean preserveHost) {
            return preserveHost(Output.of(preserveHost));
        }

        /**
         * @param protocols The list of protocols to use
         * 
         * @return builder
         * 
         */
        public Builder protocols(Output<List<String>> protocols) {
            $.protocols = protocols;
            return this;
        }

        /**
         * @param protocols The list of protocols to use
         * 
         * @return builder
         * 
         */
        public Builder protocols(List<String> protocols) {
            return protocols(Output.of(protocols));
        }

        /**
         * @param protocols The list of protocols to use
         * 
         * @return builder
         * 
         */
        public Builder protocols(String... protocols) {
            return protocols(List.of(protocols));
        }

        /**
         * @param regexPriority A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
         * 
         * @return builder
         * 
         */
        public Builder regexPriority(@Nullable Output<Integer> regexPriority) {
            $.regexPriority = regexPriority;
            return this;
        }

        /**
         * @param regexPriority A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
         * 
         * @return builder
         * 
         */
        public Builder regexPriority(Integer regexPriority) {
            return regexPriority(Output.of(regexPriority));
        }

        /**
         * @param requestBuffering Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
         * 
         * @return builder
         * 
         */
        public Builder requestBuffering(@Nullable Output<Boolean> requestBuffering) {
            $.requestBuffering = requestBuffering;
            return this;
        }

        /**
         * @param requestBuffering Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
         * 
         * @return builder
         * 
         */
        public Builder requestBuffering(Boolean requestBuffering) {
            return requestBuffering(Output.of(requestBuffering));
        }

        /**
         * @param responseBuffering Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: true.
         * 
         * @return builder
         * 
         */
        public Builder responseBuffering(@Nullable Output<Boolean> responseBuffering) {
            $.responseBuffering = responseBuffering;
            return this;
        }

        /**
         * @param responseBuffering Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: true.
         * 
         * @return builder
         * 
         */
        public Builder responseBuffering(Boolean responseBuffering) {
            return responseBuffering(Output.of(responseBuffering));
        }

        /**
         * @param serviceId Service ID to map to
         * 
         * @return builder
         * 
         */
        public Builder serviceId(Output<String> serviceId) {
            $.serviceId = serviceId;
            return this;
        }

        /**
         * @param serviceId Service ID to map to
         * 
         * @return builder
         * 
         */
        public Builder serviceId(String serviceId) {
            return serviceId(Output.of(serviceId));
        }

        /**
         * @param snis A list of SNIs that match this Route when using stream routing.
         * 
         * @return builder
         * 
         */
        public Builder snis(@Nullable Output<List<String>> snis) {
            $.snis = snis;
            return this;
        }

        /**
         * @param snis A list of SNIs that match this Route when using stream routing.
         * 
         * @return builder
         * 
         */
        public Builder snis(List<String> snis) {
            return snis(Output.of(snis));
        }

        /**
         * @param snis A list of SNIs that match this Route when using stream routing.
         * 
         * @return builder
         * 
         */
        public Builder snis(String... snis) {
            return snis(List.of(snis));
        }

        /**
         * @param sources A list of source `ip` and `port`
         * 
         * @return builder
         * 
         */
        public Builder sources(@Nullable Output<List<RouteSourceArgs>> sources) {
            $.sources = sources;
            return this;
        }

        /**
         * @param sources A list of source `ip` and `port`
         * 
         * @return builder
         * 
         */
        public Builder sources(List<RouteSourceArgs> sources) {
            return sources(Output.of(sources));
        }

        /**
         * @param sources A list of source `ip` and `port`
         * 
         * @return builder
         * 
         */
        public Builder sources(RouteSourceArgs... sources) {
            return sources(List.of(sources));
        }

        /**
         * @param stripPath When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
         * 
         * @return builder
         * 
         */
        public Builder stripPath(@Nullable Output<Boolean> stripPath) {
            $.stripPath = stripPath;
            return this;
        }

        /**
         * @param stripPath When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
         * 
         * @return builder
         * 
         */
        public Builder stripPath(Boolean stripPath) {
            return stripPath(Output.of(stripPath));
        }

        /**
         * @param tags A list of strings associated with the Route for grouping and filtering.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags A list of strings associated with the Route for grouping and filtering.
         * 
         * @return builder
         * 
         */
        public Builder tags(List<String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags A list of strings associated with the Route for grouping and filtering.
         * 
         * @return builder
         * 
         */
        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }

        public RouteArgs build() {
            if ($.protocols == null) {
                throw new MissingRequiredPropertyException("RouteArgs", "protocols");
            }
            if ($.serviceId == null) {
                throw new MissingRequiredPropertyException("RouteArgs", "serviceId");
            }
            return $;
        }
    }

}
