// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package kong

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## # Route
//
// The route resource maps directly onto the json for the route endpoint in Kong. For more information on the parameters [see the Kong Route create documentation](https://docs.konghq.com/gateway-oss/2.5.x/admin-api/#route-object).
//
// To create a tcp/tls route you set `sources` and `destinations` by repeating the corresponding element (`source` or `destination`) for each source or destination you want.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-kong/sdk/v4/go/kong"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := kong.NewRoute(ctx, "route", &kong.RouteArgs{
// 			Protocols: pulumi.StringArray{
// 				pulumi.String("http"),
// 				pulumi.String("https"),
// 			},
// 			Methods: pulumi.StringArray{
// 				pulumi.String("GET"),
// 				pulumi.String("POST"),
// 			},
// 			Hosts: pulumi.StringArray{
// 				pulumi.String("example2.com"),
// 			},
// 			Paths: pulumi.StringArray{
// 				pulumi.String("/test"),
// 			},
// 			StripPath:     pulumi.Bool(false),
// 			PreserveHost:  pulumi.Bool(true),
// 			RegexPriority: pulumi.Int(1),
// 			ServiceId:     pulumi.Any(kong_service.Service.Id),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// To create a tcp/tls route you set `sources` and `destinations` by repeating the corresponding element (`source` or `destination`) for each source or destination you want, for example:
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-kong/sdk/v4/go/kong"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := kong.NewRoute(ctx, "route", &kong.RouteArgs{
// 			Protocols: pulumi.StringArray{
// 				pulumi.String("tcp"),
// 			},
// 			StripPath:    pulumi.Bool(true),
// 			PreserveHost: pulumi.Bool(false),
// 			Sources: kong.RouteSourceArray{
// 				&kong.RouteSourceArgs{
// 					Ip:   pulumi.String("192.168.1.1"),
// 					Port: pulumi.Int(80),
// 				},
// 				&kong.RouteSourceArgs{
// 					Ip: pulumi.String("192.168.1.2"),
// 				},
// 			},
// 			Destinations: kong.RouteDestinationArray{
// 				&kong.RouteDestinationArgs{
// 					Ip:   pulumi.String("172.10.1.1"),
// 					Port: pulumi.Int(81),
// 				},
// 			},
// 			Snis: pulumi.StringArray{
// 				pulumi.String("foo.com"),
// 			},
// 			ServiceId: pulumi.Any(kong_service.Service.Id),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// To import a route
//
// ```sh
//  $ pulumi import kong:index/route:Route <route_identifier> <route_id>
// ```
type Route struct {
	pulumi.CustomResourceState

	// A list of destination `ip` and `port`
	Destinations RouteDestinationArrayOutput `pulumi:"destinations"`
	// A list of domain names that match this Route
	Hosts pulumi.StringArrayOutput `pulumi:"hosts"`
	// A list of HTTP methods that match this Route
	Methods pulumi.StringArrayOutput `pulumi:"methods"`
	// The name of the route
	Name pulumi.StringOutput `pulumi:"name"`
	// A list of paths that match this Route
	Paths pulumi.StringArrayOutput `pulumi:"paths"`
	// When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
	PreserveHost pulumi.BoolPtrOutput `pulumi:"preserveHost"`
	// The list of protocols to use
	Protocols pulumi.StringArrayOutput `pulumi:"protocols"`
	// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
	RegexPriority pulumi.IntPtrOutput `pulumi:"regexPriority"`
	// Service ID to map to
	ServiceId pulumi.StringOutput `pulumi:"serviceId"`
	// A list of SNIs that match this Route when using stream routing.
	Snis pulumi.StringArrayOutput `pulumi:"snis"`
	// A list of source `ip` and `port`
	Sources RouteSourceArrayOutput `pulumi:"sources"`
	// When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
	StripPath pulumi.BoolPtrOutput `pulumi:"stripPath"`
}

// NewRoute registers a new resource with the given unique name, arguments, and options.
func NewRoute(ctx *pulumi.Context,
	name string, args *RouteArgs, opts ...pulumi.ResourceOption) (*Route, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Protocols == nil {
		return nil, errors.New("invalid value for required argument 'Protocols'")
	}
	if args.ServiceId == nil {
		return nil, errors.New("invalid value for required argument 'ServiceId'")
	}
	var resource Route
	err := ctx.RegisterResource("kong:index/route:Route", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRoute gets an existing Route resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRoute(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RouteState, opts ...pulumi.ResourceOption) (*Route, error) {
	var resource Route
	err := ctx.ReadResource("kong:index/route:Route", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Route resources.
type routeState struct {
	// A list of destination `ip` and `port`
	Destinations []RouteDestination `pulumi:"destinations"`
	// A list of domain names that match this Route
	Hosts []string `pulumi:"hosts"`
	// A list of HTTP methods that match this Route
	Methods []string `pulumi:"methods"`
	// The name of the route
	Name *string `pulumi:"name"`
	// A list of paths that match this Route
	Paths []string `pulumi:"paths"`
	// When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
	PreserveHost *bool `pulumi:"preserveHost"`
	// The list of protocols to use
	Protocols []string `pulumi:"protocols"`
	// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
	RegexPriority *int `pulumi:"regexPriority"`
	// Service ID to map to
	ServiceId *string `pulumi:"serviceId"`
	// A list of SNIs that match this Route when using stream routing.
	Snis []string `pulumi:"snis"`
	// A list of source `ip` and `port`
	Sources []RouteSource `pulumi:"sources"`
	// When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
	StripPath *bool `pulumi:"stripPath"`
}

type RouteState struct {
	// A list of destination `ip` and `port`
	Destinations RouteDestinationArrayInput
	// A list of domain names that match this Route
	Hosts pulumi.StringArrayInput
	// A list of HTTP methods that match this Route
	Methods pulumi.StringArrayInput
	// The name of the route
	Name pulumi.StringPtrInput
	// A list of paths that match this Route
	Paths pulumi.StringArrayInput
	// When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
	PreserveHost pulumi.BoolPtrInput
	// The list of protocols to use
	Protocols pulumi.StringArrayInput
	// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
	RegexPriority pulumi.IntPtrInput
	// Service ID to map to
	ServiceId pulumi.StringPtrInput
	// A list of SNIs that match this Route when using stream routing.
	Snis pulumi.StringArrayInput
	// A list of source `ip` and `port`
	Sources RouteSourceArrayInput
	// When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
	StripPath pulumi.BoolPtrInput
}

func (RouteState) ElementType() reflect.Type {
	return reflect.TypeOf((*routeState)(nil)).Elem()
}

type routeArgs struct {
	// A list of destination `ip` and `port`
	Destinations []RouteDestination `pulumi:"destinations"`
	// A list of domain names that match this Route
	Hosts []string `pulumi:"hosts"`
	// A list of HTTP methods that match this Route
	Methods []string `pulumi:"methods"`
	// The name of the route
	Name *string `pulumi:"name"`
	// A list of paths that match this Route
	Paths []string `pulumi:"paths"`
	// When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
	PreserveHost *bool `pulumi:"preserveHost"`
	// The list of protocols to use
	Protocols []string `pulumi:"protocols"`
	// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
	RegexPriority *int `pulumi:"regexPriority"`
	// Service ID to map to
	ServiceId string `pulumi:"serviceId"`
	// A list of SNIs that match this Route when using stream routing.
	Snis []string `pulumi:"snis"`
	// A list of source `ip` and `port`
	Sources []RouteSource `pulumi:"sources"`
	// When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
	StripPath *bool `pulumi:"stripPath"`
}

// The set of arguments for constructing a Route resource.
type RouteArgs struct {
	// A list of destination `ip` and `port`
	Destinations RouteDestinationArrayInput
	// A list of domain names that match this Route
	Hosts pulumi.StringArrayInput
	// A list of HTTP methods that match this Route
	Methods pulumi.StringArrayInput
	// The name of the route
	Name pulumi.StringPtrInput
	// A list of paths that match this Route
	Paths pulumi.StringArrayInput
	// When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
	PreserveHost pulumi.BoolPtrInput
	// The list of protocols to use
	Protocols pulumi.StringArrayInput
	// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
	RegexPriority pulumi.IntPtrInput
	// Service ID to map to
	ServiceId pulumi.StringInput
	// A list of SNIs that match this Route when using stream routing.
	Snis pulumi.StringArrayInput
	// A list of source `ip` and `port`
	Sources RouteSourceArrayInput
	// When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
	StripPath pulumi.BoolPtrInput
}

func (RouteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*routeArgs)(nil)).Elem()
}

type RouteInput interface {
	pulumi.Input

	ToRouteOutput() RouteOutput
	ToRouteOutputWithContext(ctx context.Context) RouteOutput
}

func (*Route) ElementType() reflect.Type {
	return reflect.TypeOf((*Route)(nil))
}

func (i *Route) ToRouteOutput() RouteOutput {
	return i.ToRouteOutputWithContext(context.Background())
}

func (i *Route) ToRouteOutputWithContext(ctx context.Context) RouteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouteOutput)
}

func (i *Route) ToRoutePtrOutput() RoutePtrOutput {
	return i.ToRoutePtrOutputWithContext(context.Background())
}

func (i *Route) ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoutePtrOutput)
}

type RoutePtrInput interface {
	pulumi.Input

	ToRoutePtrOutput() RoutePtrOutput
	ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput
}

type routePtrType RouteArgs

func (*routePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Route)(nil))
}

func (i *routePtrType) ToRoutePtrOutput() RoutePtrOutput {
	return i.ToRoutePtrOutputWithContext(context.Background())
}

func (i *routePtrType) ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoutePtrOutput)
}

// RouteArrayInput is an input type that accepts RouteArray and RouteArrayOutput values.
// You can construct a concrete instance of `RouteArrayInput` via:
//
//          RouteArray{ RouteArgs{...} }
type RouteArrayInput interface {
	pulumi.Input

	ToRouteArrayOutput() RouteArrayOutput
	ToRouteArrayOutputWithContext(context.Context) RouteArrayOutput
}

type RouteArray []RouteInput

func (RouteArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*Route)(nil))
}

func (i RouteArray) ToRouteArrayOutput() RouteArrayOutput {
	return i.ToRouteArrayOutputWithContext(context.Background())
}

func (i RouteArray) ToRouteArrayOutputWithContext(ctx context.Context) RouteArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouteArrayOutput)
}

// RouteMapInput is an input type that accepts RouteMap and RouteMapOutput values.
// You can construct a concrete instance of `RouteMapInput` via:
//
//          RouteMap{ "key": RouteArgs{...} }
type RouteMapInput interface {
	pulumi.Input

	ToRouteMapOutput() RouteMapOutput
	ToRouteMapOutputWithContext(context.Context) RouteMapOutput
}

type RouteMap map[string]RouteInput

func (RouteMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*Route)(nil))
}

func (i RouteMap) ToRouteMapOutput() RouteMapOutput {
	return i.ToRouteMapOutputWithContext(context.Background())
}

func (i RouteMap) ToRouteMapOutputWithContext(ctx context.Context) RouteMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouteMapOutput)
}

type RouteOutput struct {
	*pulumi.OutputState
}

func (RouteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Route)(nil))
}

func (o RouteOutput) ToRouteOutput() RouteOutput {
	return o
}

func (o RouteOutput) ToRouteOutputWithContext(ctx context.Context) RouteOutput {
	return o
}

func (o RouteOutput) ToRoutePtrOutput() RoutePtrOutput {
	return o.ToRoutePtrOutputWithContext(context.Background())
}

func (o RouteOutput) ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput {
	return o.ApplyT(func(v Route) *Route {
		return &v
	}).(RoutePtrOutput)
}

type RoutePtrOutput struct {
	*pulumi.OutputState
}

func (RoutePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Route)(nil))
}

func (o RoutePtrOutput) ToRoutePtrOutput() RoutePtrOutput {
	return o
}

func (o RoutePtrOutput) ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput {
	return o
}

type RouteArrayOutput struct{ *pulumi.OutputState }

func (RouteArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Route)(nil))
}

func (o RouteArrayOutput) ToRouteArrayOutput() RouteArrayOutput {
	return o
}

func (o RouteArrayOutput) ToRouteArrayOutputWithContext(ctx context.Context) RouteArrayOutput {
	return o
}

func (o RouteArrayOutput) Index(i pulumi.IntInput) RouteOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Route {
		return vs[0].([]Route)[vs[1].(int)]
	}).(RouteOutput)
}

type RouteMapOutput struct{ *pulumi.OutputState }

func (RouteMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Route)(nil))
}

func (o RouteMapOutput) ToRouteMapOutput() RouteMapOutput {
	return o
}

func (o RouteMapOutput) ToRouteMapOutputWithContext(ctx context.Context) RouteMapOutput {
	return o
}

func (o RouteMapOutput) MapIndex(k pulumi.StringInput) RouteOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Route {
		return vs[0].(map[string]Route)[vs[1].(string)]
	}).(RouteOutput)
}

func init() {
	pulumi.RegisterOutputType(RouteOutput{})
	pulumi.RegisterOutputType(RoutePtrOutput{})
	pulumi.RegisterOutputType(RouteArrayOutput{})
	pulumi.RegisterOutputType(RouteMapOutput{})
}
