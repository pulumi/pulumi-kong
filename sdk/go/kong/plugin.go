// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package kong

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-kong/sdk/v4/go/kong/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## # Plugin
//
// The plugin resource maps directly onto the json for the API endpoint in Kong.  For more information on the parameters [see the Kong Api create documentation](https://docs.konghq.com/gateway-oss/2.5.x/admin-api/#plugin-object).
// The `configJson` is passed through to the plugin to configure it as is.
//
// ## Example Usage
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kong/sdk/v4/go/kong"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := kong.NewPlugin(ctx, "rateLimit", &kong.PluginArgs{
//				ConfigJson: pulumi.String("	{\n		\"second\": 5,\n		\"hour\" : 1000\n	}\n\n"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
// To apply a plugin to a consumer use the `consumerId` property, for example:
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kong/sdk/v4/go/kong"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			pluginConsumer, err := kong.NewConsumer(ctx, "pluginConsumer", &kong.ConsumerArgs{
//				CustomId: pulumi.String("567"),
//				Username: pulumi.String("PluginUser"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = kong.NewPlugin(ctx, "rateLimit", &kong.PluginArgs{
//				ConfigJson: pulumi.String("	{\n		\"second\": 5,\n		\"hour\" : 1000\n	}\n\n"),
//				ConsumerId: pluginConsumer.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// To apply a plugin to a service use the `serviceId` property, for example:
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kong/sdk/v4/go/kong"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			service, err := kong.NewService(ctx, "service", &kong.ServiceArgs{
//				Host:     pulumi.String("test.org"),
//				Protocol: pulumi.String("http"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = kong.NewPlugin(ctx, "rateLimit", &kong.PluginArgs{
//				ConfigJson: pulumi.String("	{\n		\"second\": 10,\n		\"hour\" : 2000\n	}\n\n"),
//				ServiceId:  service.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// To apply a plugin to a route use the `routeId` property, for example:
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kong/sdk/v4/go/kong"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			service, err := kong.NewService(ctx, "service", &kong.ServiceArgs{
//				Host:     pulumi.String("test.org"),
//				Protocol: pulumi.String("http"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = kong.NewPlugin(ctx, "rateLimit", &kong.PluginArgs{
//				ConfigJson: pulumi.String("	{\n		\"second\": 11,\n		\"hour\" : 4000\n	}\n\n"),
//				Enabled:    pulumi.Bool(true),
//				ServiceId:  service.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ## Import
//
// To import a plugin:
//
// ```sh
// $ pulumi import kong:index/plugin:Plugin <plugin_identifier> <plugin_id>
// ```
type Plugin struct {
	pulumi.CustomResourceState

	ComputedConfig pulumi.StringOutput `pulumi:"computedConfig"`
	// this is the configuration json for how you want to configure the plugin.  The json is passed straight through to kong as is.  You can get the json config from the Kong documentation
	// page of the plugin you are configuring
	ConfigJson pulumi.StringPtrOutput `pulumi:"configJson"`
	// the consumer id you want to configure the plugin for
	ConsumerId pulumi.StringPtrOutput `pulumi:"consumerId"`
	// whether the plugin is enabled or not, use if you want to keep the plugin installed but disable it
	Enabled pulumi.BoolPtrOutput `pulumi:"enabled"`
	Name    pulumi.StringOutput  `pulumi:"name"`
	// the route id that you want to configure the plugin for
	RouteId pulumi.StringPtrOutput `pulumi:"routeId"`
	// the service id that you want to configure the plugin for
	ServiceId   pulumi.StringPtrOutput `pulumi:"serviceId"`
	StrictMatch pulumi.BoolPtrOutput   `pulumi:"strictMatch"`
	// A list of strings associated with the Plugin for grouping and filtering
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
}

// NewPlugin registers a new resource with the given unique name, arguments, and options.
func NewPlugin(ctx *pulumi.Context,
	name string, args *PluginArgs, opts ...pulumi.ResourceOption) (*Plugin, error) {
	if args == nil {
		args = &PluginArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Plugin
	err := ctx.RegisterResource("kong:index/plugin:Plugin", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPlugin gets an existing Plugin resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPlugin(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PluginState, opts ...pulumi.ResourceOption) (*Plugin, error) {
	var resource Plugin
	err := ctx.ReadResource("kong:index/plugin:Plugin", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Plugin resources.
type pluginState struct {
	ComputedConfig *string `pulumi:"computedConfig"`
	// this is the configuration json for how you want to configure the plugin.  The json is passed straight through to kong as is.  You can get the json config from the Kong documentation
	// page of the plugin you are configuring
	ConfigJson *string `pulumi:"configJson"`
	// the consumer id you want to configure the plugin for
	ConsumerId *string `pulumi:"consumerId"`
	// whether the plugin is enabled or not, use if you want to keep the plugin installed but disable it
	Enabled *bool   `pulumi:"enabled"`
	Name    *string `pulumi:"name"`
	// the route id that you want to configure the plugin for
	RouteId *string `pulumi:"routeId"`
	// the service id that you want to configure the plugin for
	ServiceId   *string `pulumi:"serviceId"`
	StrictMatch *bool   `pulumi:"strictMatch"`
	// A list of strings associated with the Plugin for grouping and filtering
	Tags []string `pulumi:"tags"`
}

type PluginState struct {
	ComputedConfig pulumi.StringPtrInput
	// this is the configuration json for how you want to configure the plugin.  The json is passed straight through to kong as is.  You can get the json config from the Kong documentation
	// page of the plugin you are configuring
	ConfigJson pulumi.StringPtrInput
	// the consumer id you want to configure the plugin for
	ConsumerId pulumi.StringPtrInput
	// whether the plugin is enabled or not, use if you want to keep the plugin installed but disable it
	Enabled pulumi.BoolPtrInput
	Name    pulumi.StringPtrInput
	// the route id that you want to configure the plugin for
	RouteId pulumi.StringPtrInput
	// the service id that you want to configure the plugin for
	ServiceId   pulumi.StringPtrInput
	StrictMatch pulumi.BoolPtrInput
	// A list of strings associated with the Plugin for grouping and filtering
	Tags pulumi.StringArrayInput
}

func (PluginState) ElementType() reflect.Type {
	return reflect.TypeOf((*pluginState)(nil)).Elem()
}

type pluginArgs struct {
	// this is the configuration json for how you want to configure the plugin.  The json is passed straight through to kong as is.  You can get the json config from the Kong documentation
	// page of the plugin you are configuring
	ConfigJson *string `pulumi:"configJson"`
	// the consumer id you want to configure the plugin for
	ConsumerId *string `pulumi:"consumerId"`
	// whether the plugin is enabled or not, use if you want to keep the plugin installed but disable it
	Enabled *bool   `pulumi:"enabled"`
	Name    *string `pulumi:"name"`
	// the route id that you want to configure the plugin for
	RouteId *string `pulumi:"routeId"`
	// the service id that you want to configure the plugin for
	ServiceId   *string `pulumi:"serviceId"`
	StrictMatch *bool   `pulumi:"strictMatch"`
	// A list of strings associated with the Plugin for grouping and filtering
	Tags []string `pulumi:"tags"`
}

// The set of arguments for constructing a Plugin resource.
type PluginArgs struct {
	// this is the configuration json for how you want to configure the plugin.  The json is passed straight through to kong as is.  You can get the json config from the Kong documentation
	// page of the plugin you are configuring
	ConfigJson pulumi.StringPtrInput
	// the consumer id you want to configure the plugin for
	ConsumerId pulumi.StringPtrInput
	// whether the plugin is enabled or not, use if you want to keep the plugin installed but disable it
	Enabled pulumi.BoolPtrInput
	Name    pulumi.StringPtrInput
	// the route id that you want to configure the plugin for
	RouteId pulumi.StringPtrInput
	// the service id that you want to configure the plugin for
	ServiceId   pulumi.StringPtrInput
	StrictMatch pulumi.BoolPtrInput
	// A list of strings associated with the Plugin for grouping and filtering
	Tags pulumi.StringArrayInput
}

func (PluginArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*pluginArgs)(nil)).Elem()
}

type PluginInput interface {
	pulumi.Input

	ToPluginOutput() PluginOutput
	ToPluginOutputWithContext(ctx context.Context) PluginOutput
}

func (*Plugin) ElementType() reflect.Type {
	return reflect.TypeOf((**Plugin)(nil)).Elem()
}

func (i *Plugin) ToPluginOutput() PluginOutput {
	return i.ToPluginOutputWithContext(context.Background())
}

func (i *Plugin) ToPluginOutputWithContext(ctx context.Context) PluginOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PluginOutput)
}

// PluginArrayInput is an input type that accepts PluginArray and PluginArrayOutput values.
// You can construct a concrete instance of `PluginArrayInput` via:
//
//	PluginArray{ PluginArgs{...} }
type PluginArrayInput interface {
	pulumi.Input

	ToPluginArrayOutput() PluginArrayOutput
	ToPluginArrayOutputWithContext(context.Context) PluginArrayOutput
}

type PluginArray []PluginInput

func (PluginArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Plugin)(nil)).Elem()
}

func (i PluginArray) ToPluginArrayOutput() PluginArrayOutput {
	return i.ToPluginArrayOutputWithContext(context.Background())
}

func (i PluginArray) ToPluginArrayOutputWithContext(ctx context.Context) PluginArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PluginArrayOutput)
}

// PluginMapInput is an input type that accepts PluginMap and PluginMapOutput values.
// You can construct a concrete instance of `PluginMapInput` via:
//
//	PluginMap{ "key": PluginArgs{...} }
type PluginMapInput interface {
	pulumi.Input

	ToPluginMapOutput() PluginMapOutput
	ToPluginMapOutputWithContext(context.Context) PluginMapOutput
}

type PluginMap map[string]PluginInput

func (PluginMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Plugin)(nil)).Elem()
}

func (i PluginMap) ToPluginMapOutput() PluginMapOutput {
	return i.ToPluginMapOutputWithContext(context.Background())
}

func (i PluginMap) ToPluginMapOutputWithContext(ctx context.Context) PluginMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PluginMapOutput)
}

type PluginOutput struct{ *pulumi.OutputState }

func (PluginOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Plugin)(nil)).Elem()
}

func (o PluginOutput) ToPluginOutput() PluginOutput {
	return o
}

func (o PluginOutput) ToPluginOutputWithContext(ctx context.Context) PluginOutput {
	return o
}

func (o PluginOutput) ComputedConfig() pulumi.StringOutput {
	return o.ApplyT(func(v *Plugin) pulumi.StringOutput { return v.ComputedConfig }).(pulumi.StringOutput)
}

// this is the configuration json for how you want to configure the plugin.  The json is passed straight through to kong as is.  You can get the json config from the Kong documentation
// page of the plugin you are configuring
func (o PluginOutput) ConfigJson() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Plugin) pulumi.StringPtrOutput { return v.ConfigJson }).(pulumi.StringPtrOutput)
}

// the consumer id you want to configure the plugin for
func (o PluginOutput) ConsumerId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Plugin) pulumi.StringPtrOutput { return v.ConsumerId }).(pulumi.StringPtrOutput)
}

// whether the plugin is enabled or not, use if you want to keep the plugin installed but disable it
func (o PluginOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Plugin) pulumi.BoolPtrOutput { return v.Enabled }).(pulumi.BoolPtrOutput)
}

func (o PluginOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Plugin) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// the route id that you want to configure the plugin for
func (o PluginOutput) RouteId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Plugin) pulumi.StringPtrOutput { return v.RouteId }).(pulumi.StringPtrOutput)
}

// the service id that you want to configure the plugin for
func (o PluginOutput) ServiceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Plugin) pulumi.StringPtrOutput { return v.ServiceId }).(pulumi.StringPtrOutput)
}

func (o PluginOutput) StrictMatch() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Plugin) pulumi.BoolPtrOutput { return v.StrictMatch }).(pulumi.BoolPtrOutput)
}

// A list of strings associated with the Plugin for grouping and filtering
func (o PluginOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Plugin) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

type PluginArrayOutput struct{ *pulumi.OutputState }

func (PluginArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Plugin)(nil)).Elem()
}

func (o PluginArrayOutput) ToPluginArrayOutput() PluginArrayOutput {
	return o
}

func (o PluginArrayOutput) ToPluginArrayOutputWithContext(ctx context.Context) PluginArrayOutput {
	return o
}

func (o PluginArrayOutput) Index(i pulumi.IntInput) PluginOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Plugin {
		return vs[0].([]*Plugin)[vs[1].(int)]
	}).(PluginOutput)
}

type PluginMapOutput struct{ *pulumi.OutputState }

func (PluginMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Plugin)(nil)).Elem()
}

func (o PluginMapOutput) ToPluginMapOutput() PluginMapOutput {
	return o
}

func (o PluginMapOutput) ToPluginMapOutputWithContext(ctx context.Context) PluginMapOutput {
	return o
}

func (o PluginMapOutput) MapIndex(k pulumi.StringInput) PluginOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Plugin {
		return vs[0].(map[string]*Plugin)[vs[1].(string)]
	}).(PluginOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PluginInput)(nil)).Elem(), &Plugin{})
	pulumi.RegisterInputType(reflect.TypeOf((*PluginArrayInput)(nil)).Elem(), PluginArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PluginMapInput)(nil)).Elem(), PluginMap{})
	pulumi.RegisterOutputType(PluginOutput{})
	pulumi.RegisterOutputType(PluginArrayOutput{})
	pulumi.RegisterOutputType(PluginMapOutput{})
}
