// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package kong

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## # Plugin
//
// The plugin resource maps directly onto the json for the API endpoint in Kong.  For more information on the parameters [see the Kong Api create documentation](https://docs.konghq.com/gateway-oss/2.5.x/admin-api/#plugin-object).
// The `configJson` is passed through to the plugin to configure it as is.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"fmt"
//
// 	"github.com/pulumi/pulumi-kong/sdk/v4/go/kong"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := kong.NewPlugin(ctx, "rateLimit", &kong.PluginArgs{
// 			ConfigJson: pulumi.String(fmt.Sprintf("%v%v%v%v%v", "	{\n", "		\"second\": 5,\n", "		\"hour\" : 1000\n", "	}\n", "\n")),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// To apply a plugin to a consumer use the `consumerId` property, for example:
//
// ```go
// package main
//
// import (
// 	"fmt"
//
// 	"github.com/pulumi/pulumi-kong/sdk/v4/go/kong"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		pluginConsumer, err := kong.NewConsumer(ctx, "pluginConsumer", &kong.ConsumerArgs{
// 			CustomId: pulumi.String("567"),
// 			Username: pulumi.String("PluginUser"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = kong.NewPlugin(ctx, "rateLimit", &kong.PluginArgs{
// 			ConfigJson: pulumi.String(fmt.Sprintf("%v%v%v%v%v", "	{\n", "		\"second\": 5,\n", "		\"hour\" : 1000\n", "	}\n", "\n")),
// 			ConsumerId: pluginConsumer.ID(),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// To apply a plugin to a service use the `serviceId` property, for example:
//
// ```go
// package main
//
// import (
// 	"fmt"
//
// 	"github.com/pulumi/pulumi-kong/sdk/v4/go/kong"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		service, err := kong.NewService(ctx, "service", &kong.ServiceArgs{
// 			Host:     pulumi.String("test.org"),
// 			Protocol: pulumi.String("http"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = kong.NewPlugin(ctx, "rateLimit", &kong.PluginArgs{
// 			ConfigJson: pulumi.String(fmt.Sprintf("%v%v%v%v%v", "	{\n", "		\"second\": 10,\n", "		\"hour\" : 2000\n", "	}\n", "\n")),
// 			ServiceId: service.ID(),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// To apply a plugin to a route use the `routeId` property, for example:
//
// ```go
// package main
//
// import (
// 	"fmt"
//
// 	"github.com/pulumi/pulumi-kong/sdk/v4/go/kong"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		service, err := kong.NewService(ctx, "service", &kong.ServiceArgs{
// 			Host:     pulumi.String("test.org"),
// 			Protocol: pulumi.String("http"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = kong.NewPlugin(ctx, "rateLimit", &kong.PluginArgs{
// 			ConfigJson: pulumi.String(fmt.Sprintf("%v%v%v%v%v", "	{\n", "		\"second\": 11,\n", "		\"hour\" : 4000\n", "	}\n", "\n")),
// 			Enabled:   pulumi.Bool(true),
// 			ServiceId: service.ID(),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ## Argument reference
//
// * `pluginName` - (Required) the name of the plugin you want to configure
// * `consumerId` - (Optional) the consumer id you want to configure the plugin for
// * `serviceId`  - (Optional) the service id that you want to configure the plugin for
// * `routeId` - (Optional) the route id that you want to configure the plugin for
// * `enabled` - (Optional) whether the plugin is enabled or not, use if you want to keep the plugin installed but disable it
// * `configJson` - (Optional) this is the configuration json for how you want to configure the plugin.  The json is passed straight through to kong as is.  You can get the json config from the Kong documentation
//   page of the plugin you are configuring
// * `tags` - (Optional) A list of strings associated with the Plugin for grouping and filtering
//
// ## Import
//
// To import a plugin
//
// ```sh
//  $ pulumi import kong:index/plugin:Plugin <plugin_identifier> <plugin_id>
// ```
type Plugin struct {
	pulumi.CustomResourceState

	ComputedConfig pulumi.StringOutput `pulumi:"computedConfig"`
	// plugin configuration in JSON format, configuration must be a valid JSON object.
	ConfigJson  pulumi.StringPtrOutput   `pulumi:"configJson"`
	ConsumerId  pulumi.StringPtrOutput   `pulumi:"consumerId"`
	Enabled     pulumi.BoolPtrOutput     `pulumi:"enabled"`
	Name        pulumi.StringOutput      `pulumi:"name"`
	RouteId     pulumi.StringPtrOutput   `pulumi:"routeId"`
	ServiceId   pulumi.StringPtrOutput   `pulumi:"serviceId"`
	StrictMatch pulumi.BoolPtrOutput     `pulumi:"strictMatch"`
	Tags        pulumi.StringArrayOutput `pulumi:"tags"`
}

// NewPlugin registers a new resource with the given unique name, arguments, and options.
func NewPlugin(ctx *pulumi.Context,
	name string, args *PluginArgs, opts ...pulumi.ResourceOption) (*Plugin, error) {
	if args == nil {
		args = &PluginArgs{}
	}

	var resource Plugin
	err := ctx.RegisterResource("kong:index/plugin:Plugin", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPlugin gets an existing Plugin resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPlugin(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PluginState, opts ...pulumi.ResourceOption) (*Plugin, error) {
	var resource Plugin
	err := ctx.ReadResource("kong:index/plugin:Plugin", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Plugin resources.
type pluginState struct {
	ComputedConfig *string `pulumi:"computedConfig"`
	// plugin configuration in JSON format, configuration must be a valid JSON object.
	ConfigJson  *string  `pulumi:"configJson"`
	ConsumerId  *string  `pulumi:"consumerId"`
	Enabled     *bool    `pulumi:"enabled"`
	Name        *string  `pulumi:"name"`
	RouteId     *string  `pulumi:"routeId"`
	ServiceId   *string  `pulumi:"serviceId"`
	StrictMatch *bool    `pulumi:"strictMatch"`
	Tags        []string `pulumi:"tags"`
}

type PluginState struct {
	ComputedConfig pulumi.StringPtrInput
	// plugin configuration in JSON format, configuration must be a valid JSON object.
	ConfigJson  pulumi.StringPtrInput
	ConsumerId  pulumi.StringPtrInput
	Enabled     pulumi.BoolPtrInput
	Name        pulumi.StringPtrInput
	RouteId     pulumi.StringPtrInput
	ServiceId   pulumi.StringPtrInput
	StrictMatch pulumi.BoolPtrInput
	Tags        pulumi.StringArrayInput
}

func (PluginState) ElementType() reflect.Type {
	return reflect.TypeOf((*pluginState)(nil)).Elem()
}

type pluginArgs struct {
	// plugin configuration in JSON format, configuration must be a valid JSON object.
	ConfigJson  *string  `pulumi:"configJson"`
	ConsumerId  *string  `pulumi:"consumerId"`
	Enabled     *bool    `pulumi:"enabled"`
	Name        *string  `pulumi:"name"`
	RouteId     *string  `pulumi:"routeId"`
	ServiceId   *string  `pulumi:"serviceId"`
	StrictMatch *bool    `pulumi:"strictMatch"`
	Tags        []string `pulumi:"tags"`
}

// The set of arguments for constructing a Plugin resource.
type PluginArgs struct {
	// plugin configuration in JSON format, configuration must be a valid JSON object.
	ConfigJson  pulumi.StringPtrInput
	ConsumerId  pulumi.StringPtrInput
	Enabled     pulumi.BoolPtrInput
	Name        pulumi.StringPtrInput
	RouteId     pulumi.StringPtrInput
	ServiceId   pulumi.StringPtrInput
	StrictMatch pulumi.BoolPtrInput
	Tags        pulumi.StringArrayInput
}

func (PluginArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*pluginArgs)(nil)).Elem()
}

type PluginInput interface {
	pulumi.Input

	ToPluginOutput() PluginOutput
	ToPluginOutputWithContext(ctx context.Context) PluginOutput
}

func (*Plugin) ElementType() reflect.Type {
	return reflect.TypeOf((*Plugin)(nil))
}

func (i *Plugin) ToPluginOutput() PluginOutput {
	return i.ToPluginOutputWithContext(context.Background())
}

func (i *Plugin) ToPluginOutputWithContext(ctx context.Context) PluginOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PluginOutput)
}

func (i *Plugin) ToPluginPtrOutput() PluginPtrOutput {
	return i.ToPluginPtrOutputWithContext(context.Background())
}

func (i *Plugin) ToPluginPtrOutputWithContext(ctx context.Context) PluginPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PluginPtrOutput)
}

type PluginPtrInput interface {
	pulumi.Input

	ToPluginPtrOutput() PluginPtrOutput
	ToPluginPtrOutputWithContext(ctx context.Context) PluginPtrOutput
}

type pluginPtrType PluginArgs

func (*pluginPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Plugin)(nil))
}

func (i *pluginPtrType) ToPluginPtrOutput() PluginPtrOutput {
	return i.ToPluginPtrOutputWithContext(context.Background())
}

func (i *pluginPtrType) ToPluginPtrOutputWithContext(ctx context.Context) PluginPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PluginPtrOutput)
}

// PluginArrayInput is an input type that accepts PluginArray and PluginArrayOutput values.
// You can construct a concrete instance of `PluginArrayInput` via:
//
//          PluginArray{ PluginArgs{...} }
type PluginArrayInput interface {
	pulumi.Input

	ToPluginArrayOutput() PluginArrayOutput
	ToPluginArrayOutputWithContext(context.Context) PluginArrayOutput
}

type PluginArray []PluginInput

func (PluginArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Plugin)(nil)).Elem()
}

func (i PluginArray) ToPluginArrayOutput() PluginArrayOutput {
	return i.ToPluginArrayOutputWithContext(context.Background())
}

func (i PluginArray) ToPluginArrayOutputWithContext(ctx context.Context) PluginArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PluginArrayOutput)
}

// PluginMapInput is an input type that accepts PluginMap and PluginMapOutput values.
// You can construct a concrete instance of `PluginMapInput` via:
//
//          PluginMap{ "key": PluginArgs{...} }
type PluginMapInput interface {
	pulumi.Input

	ToPluginMapOutput() PluginMapOutput
	ToPluginMapOutputWithContext(context.Context) PluginMapOutput
}

type PluginMap map[string]PluginInput

func (PluginMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Plugin)(nil)).Elem()
}

func (i PluginMap) ToPluginMapOutput() PluginMapOutput {
	return i.ToPluginMapOutputWithContext(context.Background())
}

func (i PluginMap) ToPluginMapOutputWithContext(ctx context.Context) PluginMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PluginMapOutput)
}

type PluginOutput struct{ *pulumi.OutputState }

func (PluginOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Plugin)(nil))
}

func (o PluginOutput) ToPluginOutput() PluginOutput {
	return o
}

func (o PluginOutput) ToPluginOutputWithContext(ctx context.Context) PluginOutput {
	return o
}

func (o PluginOutput) ToPluginPtrOutput() PluginPtrOutput {
	return o.ToPluginPtrOutputWithContext(context.Background())
}

func (o PluginOutput) ToPluginPtrOutputWithContext(ctx context.Context) PluginPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Plugin) *Plugin {
		return &v
	}).(PluginPtrOutput)
}

type PluginPtrOutput struct{ *pulumi.OutputState }

func (PluginPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Plugin)(nil))
}

func (o PluginPtrOutput) ToPluginPtrOutput() PluginPtrOutput {
	return o
}

func (o PluginPtrOutput) ToPluginPtrOutputWithContext(ctx context.Context) PluginPtrOutput {
	return o
}

func (o PluginPtrOutput) Elem() PluginOutput {
	return o.ApplyT(func(v *Plugin) Plugin {
		if v != nil {
			return *v
		}
		var ret Plugin
		return ret
	}).(PluginOutput)
}

type PluginArrayOutput struct{ *pulumi.OutputState }

func (PluginArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Plugin)(nil))
}

func (o PluginArrayOutput) ToPluginArrayOutput() PluginArrayOutput {
	return o
}

func (o PluginArrayOutput) ToPluginArrayOutputWithContext(ctx context.Context) PluginArrayOutput {
	return o
}

func (o PluginArrayOutput) Index(i pulumi.IntInput) PluginOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Plugin {
		return vs[0].([]Plugin)[vs[1].(int)]
	}).(PluginOutput)
}

type PluginMapOutput struct{ *pulumi.OutputState }

func (PluginMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Plugin)(nil))
}

func (o PluginMapOutput) ToPluginMapOutput() PluginMapOutput {
	return o
}

func (o PluginMapOutput) ToPluginMapOutputWithContext(ctx context.Context) PluginMapOutput {
	return o
}

func (o PluginMapOutput) MapIndex(k pulumi.StringInput) PluginOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Plugin {
		return vs[0].(map[string]Plugin)[vs[1].(string)]
	}).(PluginOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PluginInput)(nil)).Elem(), &Plugin{})
	pulumi.RegisterInputType(reflect.TypeOf((*PluginPtrInput)(nil)).Elem(), &Plugin{})
	pulumi.RegisterInputType(reflect.TypeOf((*PluginArrayInput)(nil)).Elem(), PluginArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PluginMapInput)(nil)).Elem(), PluginMap{})
	pulumi.RegisterOutputType(PluginOutput{})
	pulumi.RegisterOutputType(PluginPtrOutput{})
	pulumi.RegisterOutputType(PluginArrayOutput{})
	pulumi.RegisterOutputType(PluginMapOutput{})
}
