// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * # kong.Route
 *
 * The route resource maps directly onto the json for the route endpoint in Kong. For more information on the parameters [see the Kong Route create documentation](https://docs.konghq.com/gateway-oss/2.5.x/admin-api/#route-object).
 *
 * To create a tcp/tls route you set `sources` and `destinations` by repeating the corresponding element (`source` or `destination`) for each source or destination you want.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as kong from "@pulumi/kong";
 *
 * const route = new kong.Route("route", {
 *     name: "MyRoute",
 *     protocols: [
 *         "http",
 *         "https",
 *     ],
 *     methods: [
 *         "GET",
 *         "POST",
 *     ],
 *     hosts: ["example2.com"],
 *     paths: ["/test"],
 *     stripPath: false,
 *     preserveHost: true,
 *     regexPriority: 1,
 *     serviceId: service.id,
 *     headers: [{
 *         name: "x-test-1",
 *         values: [
 *             "a",
 *             "b",
 *         ],
 *     }],
 * });
 * ```
 *
 * To create a tcp/tls route you set `sources` and `destinations` by repeating the corresponding element (`source` or `destination`) for each source or destination you want, for example:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as kong from "@pulumi/kong";
 *
 * const route = new kong.Route("route", {
 *     protocols: ["tcp"],
 *     stripPath: true,
 *     preserveHost: false,
 *     sources: [
 *         {
 *             ip: "192.168.1.1",
 *             port: 80,
 *         },
 *         {
 *             ip: "192.168.1.2",
 *         },
 *     ],
 *     destinations: [{
 *         ip: "172.10.1.1",
 *         port: 81,
 *     }],
 *     snis: ["foo.com"],
 *     serviceId: service.id,
 * });
 * ```
 *
 * ## Import
 *
 * To import a route:
 *
 * ```sh
 * $ pulumi import kong:index/route:Route <route_identifier> <route_id>
 * ```
 */
export class Route extends pulumi.CustomResource {
    /**
     * Get an existing Route resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: RouteState, opts?: pulumi.CustomResourceOptions): Route {
        return new Route(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'kong:index/route:Route';

    /**
     * Returns true if the given object is an instance of Route.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Route {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Route.__pulumiType;
    }

    /**
     * A list of destination `ip` and `port`
     */
    public readonly destinations!: pulumi.Output<outputs.RouteDestination[] | undefined>;
    /**
     * One or more blocks of `name` to set name of header and `values` which is a list of `string` for the header values to match on.  See above example of how to set.  These headers will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute.
     */
    public readonly headers!: pulumi.Output<outputs.RouteHeader[] | undefined>;
    /**
     * A list of domain names that match this Route
     */
    public readonly hosts!: pulumi.Output<string[] | undefined>;
    /**
     * The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
     */
    public readonly httpsRedirectStatusCode!: pulumi.Output<number | undefined>;
    /**
     * A list of HTTP methods that match this Route
     */
    public readonly methods!: pulumi.Output<string[] | undefined>;
    /**
     * The name of the route
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Controls how the Service path, Route path and requested path are combined when sending a request to the upstream.
     */
    public readonly pathHandling!: pulumi.Output<string | undefined>;
    /**
     * A list of paths that match this Route
     */
    public readonly paths!: pulumi.Output<string[] | undefined>;
    /**
     * When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
     */
    public readonly preserveHost!: pulumi.Output<boolean | undefined>;
    /**
     * The list of protocols to use
     */
    public readonly protocols!: pulumi.Output<string[]>;
    /**
     * A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
     */
    public readonly regexPriority!: pulumi.Output<number | undefined>;
    /**
     * Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
     */
    public readonly requestBuffering!: pulumi.Output<boolean | undefined>;
    /**
     * Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: true.
     */
    public readonly responseBuffering!: pulumi.Output<boolean | undefined>;
    /**
     * Service ID to map to
     */
    public readonly serviceId!: pulumi.Output<string>;
    /**
     * A list of SNIs that match this Route when using stream routing.
     */
    public readonly snis!: pulumi.Output<string[] | undefined>;
    /**
     * A list of source `ip` and `port`
     */
    public readonly sources!: pulumi.Output<outputs.RouteSource[] | undefined>;
    /**
     * When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
     */
    public readonly stripPath!: pulumi.Output<boolean | undefined>;
    /**
     * A list of strings associated with the Route for grouping and filtering.
     */
    public readonly tags!: pulumi.Output<string[] | undefined>;

    /**
     * Create a Route resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: RouteArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: RouteArgs | RouteState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as RouteState | undefined;
            resourceInputs["destinations"] = state ? state.destinations : undefined;
            resourceInputs["headers"] = state ? state.headers : undefined;
            resourceInputs["hosts"] = state ? state.hosts : undefined;
            resourceInputs["httpsRedirectStatusCode"] = state ? state.httpsRedirectStatusCode : undefined;
            resourceInputs["methods"] = state ? state.methods : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["pathHandling"] = state ? state.pathHandling : undefined;
            resourceInputs["paths"] = state ? state.paths : undefined;
            resourceInputs["preserveHost"] = state ? state.preserveHost : undefined;
            resourceInputs["protocols"] = state ? state.protocols : undefined;
            resourceInputs["regexPriority"] = state ? state.regexPriority : undefined;
            resourceInputs["requestBuffering"] = state ? state.requestBuffering : undefined;
            resourceInputs["responseBuffering"] = state ? state.responseBuffering : undefined;
            resourceInputs["serviceId"] = state ? state.serviceId : undefined;
            resourceInputs["snis"] = state ? state.snis : undefined;
            resourceInputs["sources"] = state ? state.sources : undefined;
            resourceInputs["stripPath"] = state ? state.stripPath : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
        } else {
            const args = argsOrState as RouteArgs | undefined;
            if ((!args || args.protocols === undefined) && !opts.urn) {
                throw new Error("Missing required property 'protocols'");
            }
            if ((!args || args.serviceId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'serviceId'");
            }
            resourceInputs["destinations"] = args ? args.destinations : undefined;
            resourceInputs["headers"] = args ? args.headers : undefined;
            resourceInputs["hosts"] = args ? args.hosts : undefined;
            resourceInputs["httpsRedirectStatusCode"] = args ? args.httpsRedirectStatusCode : undefined;
            resourceInputs["methods"] = args ? args.methods : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["pathHandling"] = args ? args.pathHandling : undefined;
            resourceInputs["paths"] = args ? args.paths : undefined;
            resourceInputs["preserveHost"] = args ? args.preserveHost : undefined;
            resourceInputs["protocols"] = args ? args.protocols : undefined;
            resourceInputs["regexPriority"] = args ? args.regexPriority : undefined;
            resourceInputs["requestBuffering"] = args ? args.requestBuffering : undefined;
            resourceInputs["responseBuffering"] = args ? args.responseBuffering : undefined;
            resourceInputs["serviceId"] = args ? args.serviceId : undefined;
            resourceInputs["snis"] = args ? args.snis : undefined;
            resourceInputs["sources"] = args ? args.sources : undefined;
            resourceInputs["stripPath"] = args ? args.stripPath : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Route.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Route resources.
 */
export interface RouteState {
    /**
     * A list of destination `ip` and `port`
     */
    destinations?: pulumi.Input<pulumi.Input<inputs.RouteDestination>[]>;
    /**
     * One or more blocks of `name` to set name of header and `values` which is a list of `string` for the header values to match on.  See above example of how to set.  These headers will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.RouteHeader>[]>;
    /**
     * A list of domain names that match this Route
     */
    hosts?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
     */
    httpsRedirectStatusCode?: pulumi.Input<number>;
    /**
     * A list of HTTP methods that match this Route
     */
    methods?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the route
     */
    name?: pulumi.Input<string>;
    /**
     * Controls how the Service path, Route path and requested path are combined when sending a request to the upstream.
     */
    pathHandling?: pulumi.Input<string>;
    /**
     * A list of paths that match this Route
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
     */
    preserveHost?: pulumi.Input<boolean>;
    /**
     * The list of protocols to use
     */
    protocols?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
     */
    regexPriority?: pulumi.Input<number>;
    /**
     * Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
     */
    requestBuffering?: pulumi.Input<boolean>;
    /**
     * Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: true.
     */
    responseBuffering?: pulumi.Input<boolean>;
    /**
     * Service ID to map to
     */
    serviceId?: pulumi.Input<string>;
    /**
     * A list of SNIs that match this Route when using stream routing.
     */
    snis?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A list of source `ip` and `port`
     */
    sources?: pulumi.Input<pulumi.Input<inputs.RouteSource>[]>;
    /**
     * When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
     */
    stripPath?: pulumi.Input<boolean>;
    /**
     * A list of strings associated with the Route for grouping and filtering.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
}

/**
 * The set of arguments for constructing a Route resource.
 */
export interface RouteArgs {
    /**
     * A list of destination `ip` and `port`
     */
    destinations?: pulumi.Input<pulumi.Input<inputs.RouteDestination>[]>;
    /**
     * One or more blocks of `name` to set name of header and `values` which is a list of `string` for the header values to match on.  See above example of how to set.  These headers will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.RouteHeader>[]>;
    /**
     * A list of domain names that match this Route
     */
    hosts?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
     */
    httpsRedirectStatusCode?: pulumi.Input<number>;
    /**
     * A list of HTTP methods that match this Route
     */
    methods?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the route
     */
    name?: pulumi.Input<string>;
    /**
     * Controls how the Service path, Route path and requested path are combined when sending a request to the upstream.
     */
    pathHandling?: pulumi.Input<string>;
    /**
     * A list of paths that match this Route
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
     */
    preserveHost?: pulumi.Input<boolean>;
    /**
     * The list of protocols to use
     */
    protocols: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
     */
    regexPriority?: pulumi.Input<number>;
    /**
     * Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
     */
    requestBuffering?: pulumi.Input<boolean>;
    /**
     * Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: true.
     */
    responseBuffering?: pulumi.Input<boolean>;
    /**
     * Service ID to map to
     */
    serviceId: pulumi.Input<string>;
    /**
     * A list of SNIs that match this Route when using stream routing.
     */
    snis?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A list of source `ip` and `port`
     */
    sources?: pulumi.Input<pulumi.Input<inputs.RouteSource>[]>;
    /**
     * When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
     */
    stripPath?: pulumi.Input<boolean>;
    /**
     * A list of strings associated with the Route for grouping and filtering.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
}
