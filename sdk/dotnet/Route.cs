// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Kong
{
    /// <summary>
    /// ## # kong.Route
    /// 
    /// The route resource maps directly onto the json for the route endpoint in Kong. For more information on the parameters [see the Kong Route create documentation](https://docs.konghq.com/gateway-oss/2.5.x/admin-api/#route-object).
    /// 
    /// To create a tcp/tls route you set `sources` and `destinations` by repeating the corresponding element (`source` or `destination`) for each source or destination you want.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Kong = Pulumi.Kong;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var route = new Kong.Route("route", new()
    ///     {
    ///         Name = "MyRoute",
    ///         Protocols = new[]
    ///         {
    ///             "http",
    ///             "https",
    ///         },
    ///         Methods = new[]
    ///         {
    ///             "GET",
    ///             "POST",
    ///         },
    ///         Hosts = new[]
    ///         {
    ///             "example2.com",
    ///         },
    ///         Paths = new[]
    ///         {
    ///             "/test",
    ///         },
    ///         StripPath = false,
    ///         PreserveHost = true,
    ///         RegexPriority = 1,
    ///         ServiceId = service.Id,
    ///         Headers = new[]
    ///         {
    ///             new Kong.Inputs.RouteHeaderArgs
    ///             {
    ///                 Name = "x-test-1",
    ///                 Values = new[]
    ///                 {
    ///                     "a",
    ///                     "b",
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// To create a tcp/tls route you set `sources` and `destinations` by repeating the corresponding element (`source` or `destination`) for each source or destination you want, for example:
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Kong = Pulumi.Kong;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var route = new Kong.Route("route", new()
    ///     {
    ///         Protocols = new[]
    ///         {
    ///             "tcp",
    ///         },
    ///         StripPath = true,
    ///         PreserveHost = false,
    ///         Sources = new[]
    ///         {
    ///             new Kong.Inputs.RouteSourceArgs
    ///             {
    ///                 Ip = "192.168.1.1",
    ///                 Port = 80,
    ///             },
    ///             new Kong.Inputs.RouteSourceArgs
    ///             {
    ///                 Ip = "192.168.1.2",
    ///             },
    ///         },
    ///         Destinations = new[]
    ///         {
    ///             new Kong.Inputs.RouteDestinationArgs
    ///             {
    ///                 Ip = "172.10.1.1",
    ///                 Port = 81,
    ///             },
    ///         },
    ///         Snis = new[]
    ///         {
    ///             "foo.com",
    ///         },
    ///         ServiceId = service.Id,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// To import a route:
    /// 
    /// ```sh
    /// $ pulumi import kong:index/route:Route &lt;route_identifier&gt; &lt;route_id&gt;
    /// ```
    /// </summary>
    [KongResourceType("kong:index/route:Route")]
    public partial class Route : global::Pulumi.CustomResource
    {
        /// <summary>
        /// A list of destination `ip` and `port`
        /// </summary>
        [Output("destinations")]
        public Output<ImmutableArray<Outputs.RouteDestination>> Destinations { get; private set; } = null!;

        /// <summary>
        /// One or more blocks of `name` to set name of header and `values` which is a list of `string` for the header values to match on.  See above example of how to set.  These headers will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute.
        /// </summary>
        [Output("headers")]
        public Output<ImmutableArray<Outputs.RouteHeader>> Headers { get; private set; } = null!;

        /// <summary>
        /// A list of domain names that match this Route
        /// </summary>
        [Output("hosts")]
        public Output<ImmutableArray<string>> Hosts { get; private set; } = null!;

        /// <summary>
        /// The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
        /// </summary>
        [Output("httpsRedirectStatusCode")]
        public Output<int?> HttpsRedirectStatusCode { get; private set; } = null!;

        /// <summary>
        /// A list of HTTP methods that match this Route
        /// </summary>
        [Output("methods")]
        public Output<ImmutableArray<string>> Methods { get; private set; } = null!;

        /// <summary>
        /// The name of the route
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Controls how the Service path, Route path and requested path are combined when sending a request to the upstream.
        /// </summary>
        [Output("pathHandling")]
        public Output<string?> PathHandling { get; private set; } = null!;

        /// <summary>
        /// A list of paths that match this Route
        /// </summary>
        [Output("paths")]
        public Output<ImmutableArray<string>> Paths { get; private set; } = null!;

        /// <summary>
        /// When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
        /// </summary>
        [Output("preserveHost")]
        public Output<bool?> PreserveHost { get; private set; } = null!;

        /// <summary>
        /// The list of protocols to use
        /// </summary>
        [Output("protocols")]
        public Output<ImmutableArray<string>> Protocols { get; private set; } = null!;

        /// <summary>
        /// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
        /// </summary>
        [Output("regexPriority")]
        public Output<int?> RegexPriority { get; private set; } = null!;

        /// <summary>
        /// Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
        /// </summary>
        [Output("requestBuffering")]
        public Output<bool?> RequestBuffering { get; private set; } = null!;

        /// <summary>
        /// Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: true.
        /// </summary>
        [Output("responseBuffering")]
        public Output<bool?> ResponseBuffering { get; private set; } = null!;

        /// <summary>
        /// Service ID to map to
        /// </summary>
        [Output("serviceId")]
        public Output<string> ServiceId { get; private set; } = null!;

        /// <summary>
        /// A list of SNIs that match this Route when using stream routing.
        /// </summary>
        [Output("snis")]
        public Output<ImmutableArray<string>> Snis { get; private set; } = null!;

        /// <summary>
        /// A list of source `ip` and `port`
        /// </summary>
        [Output("sources")]
        public Output<ImmutableArray<Outputs.RouteSource>> Sources { get; private set; } = null!;

        /// <summary>
        /// When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
        /// </summary>
        [Output("stripPath")]
        public Output<bool?> StripPath { get; private set; } = null!;

        /// <summary>
        /// A list of strings associated with the Route for grouping and filtering.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;


        /// <summary>
        /// Create a Route resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Route(string name, RouteArgs args, CustomResourceOptions? options = null)
            : base("kong:index/route:Route", name, args ?? new RouteArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Route(string name, Input<string> id, RouteState? state = null, CustomResourceOptions? options = null)
            : base("kong:index/route:Route", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Route resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Route Get(string name, Input<string> id, RouteState? state = null, CustomResourceOptions? options = null)
        {
            return new Route(name, id, state, options);
        }
    }

    public sealed class RouteArgs : global::Pulumi.ResourceArgs
    {
        [Input("destinations")]
        private InputList<Inputs.RouteDestinationArgs>? _destinations;

        /// <summary>
        /// A list of destination `ip` and `port`
        /// </summary>
        public InputList<Inputs.RouteDestinationArgs> Destinations
        {
            get => _destinations ?? (_destinations = new InputList<Inputs.RouteDestinationArgs>());
            set => _destinations = value;
        }

        [Input("headers")]
        private InputList<Inputs.RouteHeaderArgs>? _headers;

        /// <summary>
        /// One or more blocks of `name` to set name of header and `values` which is a list of `string` for the header values to match on.  See above example of how to set.  These headers will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute.
        /// </summary>
        public InputList<Inputs.RouteHeaderArgs> Headers
        {
            get => _headers ?? (_headers = new InputList<Inputs.RouteHeaderArgs>());
            set => _headers = value;
        }

        [Input("hosts")]
        private InputList<string>? _hosts;

        /// <summary>
        /// A list of domain names that match this Route
        /// </summary>
        public InputList<string> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<string>());
            set => _hosts = value;
        }

        /// <summary>
        /// The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
        /// </summary>
        [Input("httpsRedirectStatusCode")]
        public Input<int>? HttpsRedirectStatusCode { get; set; }

        [Input("methods")]
        private InputList<string>? _methods;

        /// <summary>
        /// A list of HTTP methods that match this Route
        /// </summary>
        public InputList<string> Methods
        {
            get => _methods ?? (_methods = new InputList<string>());
            set => _methods = value;
        }

        /// <summary>
        /// The name of the route
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Controls how the Service path, Route path and requested path are combined when sending a request to the upstream.
        /// </summary>
        [Input("pathHandling")]
        public Input<string>? PathHandling { get; set; }

        [Input("paths")]
        private InputList<string>? _paths;

        /// <summary>
        /// A list of paths that match this Route
        /// </summary>
        public InputList<string> Paths
        {
            get => _paths ?? (_paths = new InputList<string>());
            set => _paths = value;
        }

        /// <summary>
        /// When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
        /// </summary>
        [Input("preserveHost")]
        public Input<bool>? PreserveHost { get; set; }

        [Input("protocols", required: true)]
        private InputList<string>? _protocols;

        /// <summary>
        /// The list of protocols to use
        /// </summary>
        public InputList<string> Protocols
        {
            get => _protocols ?? (_protocols = new InputList<string>());
            set => _protocols = value;
        }

        /// <summary>
        /// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
        /// </summary>
        [Input("regexPriority")]
        public Input<int>? RegexPriority { get; set; }

        /// <summary>
        /// Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
        /// </summary>
        [Input("requestBuffering")]
        public Input<bool>? RequestBuffering { get; set; }

        /// <summary>
        /// Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: true.
        /// </summary>
        [Input("responseBuffering")]
        public Input<bool>? ResponseBuffering { get; set; }

        /// <summary>
        /// Service ID to map to
        /// </summary>
        [Input("serviceId", required: true)]
        public Input<string> ServiceId { get; set; } = null!;

        [Input("snis")]
        private InputList<string>? _snis;

        /// <summary>
        /// A list of SNIs that match this Route when using stream routing.
        /// </summary>
        public InputList<string> Snis
        {
            get => _snis ?? (_snis = new InputList<string>());
            set => _snis = value;
        }

        [Input("sources")]
        private InputList<Inputs.RouteSourceArgs>? _sources;

        /// <summary>
        /// A list of source `ip` and `port`
        /// </summary>
        public InputList<Inputs.RouteSourceArgs> Sources
        {
            get => _sources ?? (_sources = new InputList<Inputs.RouteSourceArgs>());
            set => _sources = value;
        }

        /// <summary>
        /// When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
        /// </summary>
        [Input("stripPath")]
        public Input<bool>? StripPath { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// A list of strings associated with the Route for grouping and filtering.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        public RouteArgs()
        {
        }
        public static new RouteArgs Empty => new RouteArgs();
    }

    public sealed class RouteState : global::Pulumi.ResourceArgs
    {
        [Input("destinations")]
        private InputList<Inputs.RouteDestinationGetArgs>? _destinations;

        /// <summary>
        /// A list of destination `ip` and `port`
        /// </summary>
        public InputList<Inputs.RouteDestinationGetArgs> Destinations
        {
            get => _destinations ?? (_destinations = new InputList<Inputs.RouteDestinationGetArgs>());
            set => _destinations = value;
        }

        [Input("headers")]
        private InputList<Inputs.RouteHeaderGetArgs>? _headers;

        /// <summary>
        /// One or more blocks of `name` to set name of header and `values` which is a list of `string` for the header values to match on.  See above example of how to set.  These headers will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute.
        /// </summary>
        public InputList<Inputs.RouteHeaderGetArgs> Headers
        {
            get => _headers ?? (_headers = new InputList<Inputs.RouteHeaderGetArgs>());
            set => _headers = value;
        }

        [Input("hosts")]
        private InputList<string>? _hosts;

        /// <summary>
        /// A list of domain names that match this Route
        /// </summary>
        public InputList<string> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<string>());
            set => _hosts = value;
        }

        /// <summary>
        /// The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
        /// </summary>
        [Input("httpsRedirectStatusCode")]
        public Input<int>? HttpsRedirectStatusCode { get; set; }

        [Input("methods")]
        private InputList<string>? _methods;

        /// <summary>
        /// A list of HTTP methods that match this Route
        /// </summary>
        public InputList<string> Methods
        {
            get => _methods ?? (_methods = new InputList<string>());
            set => _methods = value;
        }

        /// <summary>
        /// The name of the route
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Controls how the Service path, Route path and requested path are combined when sending a request to the upstream.
        /// </summary>
        [Input("pathHandling")]
        public Input<string>? PathHandling { get; set; }

        [Input("paths")]
        private InputList<string>? _paths;

        /// <summary>
        /// A list of paths that match this Route
        /// </summary>
        public InputList<string> Paths
        {
            get => _paths ?? (_paths = new InputList<string>());
            set => _paths = value;
        }

        /// <summary>
        /// When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service’s host.
        /// </summary>
        [Input("preserveHost")]
        public Input<bool>? PreserveHost { get; set; }

        [Input("protocols")]
        private InputList<string>? _protocols;

        /// <summary>
        /// The list of protocols to use
        /// </summary>
        public InputList<string> Protocols
        {
            get => _protocols ?? (_protocols = new InputList<string>());
            set => _protocols = value;
        }

        /// <summary>
        /// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously.
        /// </summary>
        [Input("regexPriority")]
        public Input<int>? RegexPriority { get; set; }

        /// <summary>
        /// Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
        /// </summary>
        [Input("requestBuffering")]
        public Input<bool>? RequestBuffering { get; set; }

        /// <summary>
        /// Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: true.
        /// </summary>
        [Input("responseBuffering")]
        public Input<bool>? ResponseBuffering { get; set; }

        /// <summary>
        /// Service ID to map to
        /// </summary>
        [Input("serviceId")]
        public Input<string>? ServiceId { get; set; }

        [Input("snis")]
        private InputList<string>? _snis;

        /// <summary>
        /// A list of SNIs that match this Route when using stream routing.
        /// </summary>
        public InputList<string> Snis
        {
            get => _snis ?? (_snis = new InputList<string>());
            set => _snis = value;
        }

        [Input("sources")]
        private InputList<Inputs.RouteSourceGetArgs>? _sources;

        /// <summary>
        /// A list of source `ip` and `port`
        /// </summary>
        public InputList<Inputs.RouteSourceGetArgs> Sources
        {
            get => _sources ?? (_sources = new InputList<Inputs.RouteSourceGetArgs>());
            set => _sources = value;
        }

        /// <summary>
        /// When matching a Route via one of the paths, strip the matching prefix from the upstream request URL. Default: true.
        /// </summary>
        [Input("stripPath")]
        public Input<bool>? StripPath { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// A list of strings associated with the Route for grouping and filtering.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        public RouteState()
        {
        }
        public static new RouteState Empty => new RouteState();
    }
}
